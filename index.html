<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Kiddo Activities</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:," />
  <style>
    html {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
        "Segoe UI Symbol";
      font-size: 16px;
      line-height: 1.6;
    }

    body {
      margin: 0;
      background-color: white;
      padding: 0 2em;
    }

    p {
      margin: 1.5em 0;
    }

    .intro {
      box-sizing: border-box;
      width: 100%;
      margin: 0 0 1.5em 0;
      padding: 1em 0;
      border-bottom: 1px solid #999;
    }

    .intro h1 {
      margin: 0 0 0.5em 0;
    }

    .intro p {
      margin: 0;
    }

    .interface {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
    }

    .interface .controls {
      box-sizing: border-box;
      width: 300px;
      flex-shrink: 0;
      padding: 1em;
    }

    .interface .preview {
      box-sizing: border-box;
      flex: 1;
      padding: 1em;
    }

    .controls fieldset {
      margin-bottom: 1em;
      border: 1px solid #ccc;
    }

    .controls legend {
      font-weight: bold;
      padding: 0 0.5em;
    }

    .controls label {
      display: block;
      margin-bottom: 0.5em;
    }

    .controls label > span {
      display: block;
      font-weight: normal;
      margin-bottom: 0.25em;
    }

    .controls input[type="range"],
    .controls select {
      width: 100%;
      box-sizing: border-box;
      font-size: 1em;
    }

    .controls input[type="range"] {
      margin-top: 0.25em;
    }

    .controls button {
      width: 100%;
      padding: 0.5em 1em;
      font-size: 1em;
      margin-bottom: 0.5em;
      cursor: pointer;
    }

    #preview-pages {
      display: flex;
      flex-wrap: wrap;
      background-color: #eee;
      margin: 1em -1em;
      padding: 0.5em;
      min-height: 200px;
    }

    .page-thumbnail {
      width: 250px;
      margin: 0.5em;
      background-color: white;
      border: 1px solid #ccc;
      position: relative;
      box-sizing: border-box;
    }

    .page-thumbnail svg {
      width: 100%;
      height: auto;
      display: block;
    }

    .page-thumbnail .delete-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      background-color: rgba(255, 255, 255, 0.9);
      border: 1px solid #999;
      padding: 0.25em 0.5em;
      cursor: pointer;
      font-size: 0.8em;
    }

    .page-thumbnail .delete-btn:hover {
      background-color: #ff6b6b;
      color: white;
    }

    .activity-params {
      display: none;
    }

    .activity-params.active {
      display: block;
    }

    /* Mobile responsiveness */
    @media (max-width: 600px) {
      body {
        padding: 0 0.5em;
      }

      .interface {
        flex-direction: column;
      }

      .interface .controls {
        width: 100%;
      }
    }
  </style>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>

<body>
  <div class="intro">
    <h1>Kiddo Activities</h1>
    <p>Create printable activity pages for kids!</p>
  </div>

  <div class="interface">
    <div class="controls">
      <fieldset>
        <legend>Activity Type</legend>
        <label>
          <select id="activity-type">
            <!-- Options will be generated dynamically -->
          </select>
        </label>
      </fieldset>

      <!-- Parameter fieldsets will be generated dynamically -->
      <div id="params-container"></div>

      <button id="add-page-btn">Add Page</button>
      <button id="print-btn">Generate PDF</button>
    </div>

    <div class="preview">
      <div id="preview-pages">
        <!-- Page thumbnails will be added here -->
      </div>
    </div>
  </div>

  <script type="module">
    // ============================================================================
    // MODULE REGISTRY
    // ============================================================================

    import * as mazeModule from './maze.js';
    import * as mathModule from './math.js';
    import * as comicModule from './comic.js';

    const activityModules = [
      mazeModule,
      mathModule,
      comicModule
    ];

    // Create lookup by ID
    const moduleById = {};
    activityModules.forEach(module => {
      moduleById[module.id] = module;
    });

    // ============================================================================
    // UI GENERATION
    // ============================================================================

    function initializeUI() {
      const activityTypeSelect = document.getElementById('activity-type');
      const paramsContainer = document.getElementById('params-container');

      // Generate activity type dropdown options
      activityModules.forEach(module => {
        const option = document.createElement('option');
        option.value = module.id;
        option.textContent = module.name;
        activityTypeSelect.appendChild(option);
      });

      // Generate parameter fieldsets for each module
      activityModules.forEach(module => {
        const fieldset = document.createElement('fieldset');
        fieldset.id = `params-${module.id}`;
        fieldset.className = 'activity-params';

        const legend = document.createElement('legend');
        legend.textContent = `${module.name} Settings`;
        fieldset.appendChild(legend);

        module.options.forEach(option => {
          const label = document.createElement('label');

          const span = document.createElement('span');
          span.innerHTML = `${option.label}: <span id="${module.id}-${option.id}-value">${option.defaultValue}</span>`;
          label.appendChild(span);

          const input = document.createElement('input');
          input.type = 'range';
          input.id = `${module.id}-${option.id}`;
          input.min = option.min;
          input.max = option.max;
          input.value = option.defaultValue;
          label.appendChild(input);

          fieldset.appendChild(label);
        });

        paramsContainer.appendChild(fieldset);
      });

      // Show first activity's params by default
      document.querySelector('.activity-params').classList.add('active');

      // Set up activity type selector
      activityTypeSelect.addEventListener('change', () => {
        document.querySelectorAll('.activity-params').forEach(el => {
          el.classList.remove('active');
        });
        document.getElementById(`params-${activityTypeSelect.value}`).classList.add('active');
      });

      // Set up slider value displays
      activityModules.forEach(module => {
        module.options.forEach(option => {
          const slider = document.getElementById(`${module.id}-${option.id}`);
          const valueDisplay = document.getElementById(`${module.id}-${option.id}-value`);

          // Sync display with actual slider value on page load
          valueDisplay.textContent = slider.value;

          slider.addEventListener('input', () => {
            valueDisplay.textContent = slider.value;
          });
        });
      });
    }

    // ============================================================================
    // PAGE MANAGEMENT
    // ============================================================================

    const state = {
      pages: [],
      nextId: 1
    };

    function addPage(type, svg) {
      const page = {
        id: state.nextId++,
        type: type,
        svg: svg
      };
      state.pages.unshift(page);  // Prepend instead of append
      renderPreview();
      updatePrintButton();
    }

    function deletePage(id) {
      state.pages = state.pages.filter(page => page.id !== id);
      renderPreview();
      updatePrintButton();
    }

    function updatePrintButton() {
      const printBtn = document.getElementById('print-btn');
      const count = state.pages.length;
      if (count === 0) {
        printBtn.textContent = 'Generate PDF';
      } else if (count === 1) {
        printBtn.textContent = 'Generate PDF (1 page)';
      } else {
        printBtn.textContent = `Generate PDF (${count} pages)`;
      }
    }

    function renderPreview() {
      const container = document.getElementById('preview-pages');
      container.innerHTML = '';

      state.pages.forEach(page => {
        const div = document.createElement('div');
        div.className = 'page-thumbnail';

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.onclick = () => deletePage(page.id);

        div.innerHTML = page.svg;
        div.appendChild(deleteBtn);
        container.appendChild(div);
      });
    }

    // ============================================================================
    // ADD PAGE BUTTON
    // ============================================================================

    document.getElementById('add-page-btn').addEventListener('click', () => {
      const activityType = document.getElementById('activity-type').value;
      const module = moduleById[activityType];

      // Collect parameter values
      const params = {};
      module.options.forEach(option => {
        const slider = document.getElementById(`${module.id}-${option.id}`);
        params[option.id] = parseInt(slider.value);
      });

      // Generate SVG using the module
      const svg = module.generate(params);

      if (svg) {
        addPage(activityType, svg);
      }
    });

    // ============================================================================
    // INITIALIZATION
    // ============================================================================

    initializeUI();
    updatePrintButton();

    // ============================================================================
    // PDF GENERATION
    // ============================================================================

    document.getElementById('print-btn').addEventListener('click', async () => {
      if (state.pages.length === 0) {
        alert('Add some pages first!');
        return;
      }

      try {
        const pdfDoc = await PDFLib.PDFDocument.create();

        // Add each page to the PDF
        for (const page of state.pages) {
          // Create a new page (US Letter: 612 x 792 points)
          const pdfPage = pdfDoc.addPage([612, 792]);

          // Parse the SVG and extract the path data
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(page.svg, 'image/svg+xml');
          const paths = svgDoc.querySelectorAll('path');
          const lines = svgDoc.querySelectorAll('line');
          const rects = svgDoc.querySelectorAll('rect');
          const texts = svgDoc.querySelectorAll('text');

          // Draw each path element
          paths.forEach(pathElement => {
            const d = pathElement.getAttribute('d');
            const strokeWidth = parseFloat(pathElement.getAttribute('stroke-width') || 1);
            const transform = pathElement.parentElement?.getAttribute('transform') || '';

            // Extract translation if present
            let translateX = 0, translateY = 0;
            const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
            if (translateMatch) {
              translateX = parseFloat(translateMatch[1]);
              translateY = parseFloat(translateMatch[2]);
            }

            // Apply transformation to the path
            let transformedPath = d;
            if (translateX !== 0 || translateY !== 0) {
              // Create a temporary transform for the path (handle negative numbers)
              transformedPath = d.replace(/([ML])\s*(-?[\d.]+),\s*(-?[\d.]+)/g, (match, cmd, x, y) => {
                const newX = parseFloat(x) + translateX;
                const newY = parseFloat(y) + translateY;
                return `${cmd} ${newX},${newY}`;
              });
            }

            pdfPage.drawSvgPath(transformedPath, {
              x: 0,
              y: 792,
              borderColor: PDFLib.rgb(0, 0, 0),
              borderWidth: strokeWidth,
            });
          });

          // Draw each line element
          lines.forEach(lineElement => {
            const x1 = parseFloat(lineElement.getAttribute('x1'));
            const y1 = parseFloat(lineElement.getAttribute('y1'));
            const x2 = parseFloat(lineElement.getAttribute('x2'));
            const y2 = parseFloat(lineElement.getAttribute('y2'));
            const strokeWidth = parseFloat(lineElement.getAttribute('stroke-width') || 1);

            pdfPage.drawLine({
              start: { x: x1, y: 792 - y1 },
              end: { x: x2, y: 792 - y2 },
              thickness: strokeWidth,
              color: PDFLib.rgb(0, 0, 0),
            });
          });

          // Draw each rect element
          rects.forEach(rectElement => {
            const x = parseFloat(rectElement.getAttribute('x'));
            const y = parseFloat(rectElement.getAttribute('y'));
            const width = parseFloat(rectElement.getAttribute('width'));
            const height = parseFloat(rectElement.getAttribute('height'));
            const strokeWidth = parseFloat(rectElement.getAttribute('stroke-width') || 1);

            pdfPage.drawRectangle({
              x: x,
              y: 792 - y - height,
              width: width,
              height: height,
              borderColor: PDFLib.rgb(0, 0, 0),
              borderWidth: strokeWidth,
            });
          });

          // Draw each text element
          for (const textElement of texts) {
            const x = parseFloat(textElement.getAttribute('x'));
            const y = parseFloat(textElement.getAttribute('y'));
            const fontSize = parseFloat(textElement.getAttribute('font-size') || 12);
            const textAnchor = textElement.getAttribute('text-anchor') || 'start';
            const content = textElement.textContent;

            // Embed font (using Helvetica as default)
            const font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);

            // Calculate text width for anchoring
            const textWidth = font.widthOfTextAtSize(content, fontSize);
            let adjustedX = x;
            if (textAnchor === 'middle') {
              adjustedX = x - textWidth / 2;
            } else if (textAnchor === 'end') {
              adjustedX = x - textWidth;
            }

            pdfPage.drawText(content, {
              x: adjustedX,
              y: 792 - y,
              size: fontSize,
              font: font,
              color: PDFLib.rgb(0, 0, 0),
            });
          }
        }

        // Save and download the PDF
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        window.open(url, '_blank');
      } catch (error) {
        console.error('PDF generation error:', error);
        alert('Error generating PDF: ' + error.message);
      }
    });

  </script>
</body>

</html>
